name: Sync RBL to Cortex XDR (best-effort)

on:
  push:
    paths:
      - 'fqdnlist.txt'
      - 'iplist.txt'
      - 'hashlist.txt'
      - '.github/workflows/xdr-ioc-sync.yml'
  workflow_dispatch: {}

jobs:
  sync:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Push IOCs to Cortex XDR (best-effort)
        env:
          XDR_BASE_URL: ${{ secrets.XDR_BASE_URL }}
          XDR_API_ID:   ${{ secrets.XDR_API_ID }}
          XDR_API_KEY:  ${{ secrets.XDR_API_KEY }}
          VENDOR:       ONO-RBL
          COMMENT_TAG:  "GitHub sync"
          SOURCES:      "fqdnlist.txt,iplist.txt,hashlist.txt"
          BATCH_SIZE:   "1000"
        run: |
          python - <<'PY' || true
          import os, sys, time, json, re, requests
          BASE   = os.environ["XDR_BASE_URL"].rstrip("/")
          API_ID = os.environ["XDR_API_ID"]
          APIKEY = os.environ["XDR_API_KEY"]
          VENDOR = os.getenv("VENDOR","ONO-RBL")
          COMMENT= os.getenv("COMMENT_TAG","GitHub sync")
          SOURCES= [s.strip() for s in os.getenv("SOURCES","").split(",") if s.strip()]
          BATCH  = int(os.getenv("BATCH_SIZE","1000"))

          H = {"Authorization":APIKEY, "x-xdr-auth-id":API_ID, "Content-Type":"application/json", "Accept":"application/json"}

          dom_re = re.compile(r"^[A-Za-z0-9][A-Za-z0-9.-]{1,251}\.[A-Za-z]{2,63}$")
          ip_re  = re.compile(r"^(?:\d{1,3}\.){3}\d{1,3}$")
          sha256 = re.compile(r"^[a-fA-F0-9]{64}$")

          def parse_lines(paths):
            total, good, bad = 0, [], []
            for p in paths:
              if not os.path.exists(p): continue
              print(f"[src] {p}")
              with open(p,"r",encoding="utf-8",errors="ignore") as f:
                for line in f:
                  total+=1
                  s=line.strip().strip(",")
                  if not s or s.startswith(("#",";")): continue
                  # normalize
                  s = s.replace("\u200b","").replace("\u200e","").strip()
                  if sha256.fullmatch(s):
                    good.append({"indicator":s,"type":"HASH"})
                  elif ip_re.fullmatch(s):
                    good.append({"indicator":s,"type":"IP"})
                  elif "/" in s:  # skip CIDR
                    bad.append({"line":s,"why":"CIDR not supported"})
                  elif dom_re.fullmatch(s):
                    good.append({"indicator":s.lower(),"type":"DOMAIN_NAME"})
                  else:
                    bad.append({"line":s,"why":"unknown format"})
            return total, good, bad

          def post(uri, payload, retries=6, timeout=90):
            back=2
            for i in range(1,retries+1):
              try:
                r = requests.post(uri, headers=H, json=payload, timeout=timeout)
                if r.status_code in (429,500,502,503,504,599):
                  sleep = int(r.headers.get("Retry-After","0") or 0) or back
                  print(f"[retry] HTTP {r.status_code} sleeping {sleep}s (attempt {i}/{retries})")
                  time.sleep(sleep); back=min(int(back*2.2),90); continue
                r.raise_for_status()
                return r.json(), None
              except requests.RequestException as e:
                if i==retries: return None, str(e)
                time.sleep(back); back=min(int(back*2.2),90)
            return None, "unreachable"

          total, inds, rejects = parse_lines(SOURCES)
          # enrich
          for it in inds:
            it["severity"]="HIGH"
            it["reputation"]="BAD"
            it["comment"]=COMMENT
            it["vendor"]={"name":VENDOR}

          print(f"[parse] files={len(SOURCES)} lines_total={total} parsed={len(inds)} rejected={len(rejects)}")
          if rejects:
            with open("rejects.json","w",encoding="utf-8") as f: json.dump(rejects,f,ensure_ascii=False,indent=2)

          uri = f"{BASE}/public_api/v1/indicators/insert_jsons"
          print(f"Using endpoint: {uri}")
          uploaded=0; api_errs=0
          for i in range(0,len(inds),BATCH):
            chunk = inds[i:i+BATCH]
            body  = {"request_data":{"indicators":chunk}}
            print(f"[batch] {i+1}-{i+len(chunk)} / {len(inds)}", flush=True)
            js, err = post(uri, body)
            if err:
              api_errs+=len(chunk)
              print(f"[batch] API error: {err}")
            else:
              uploaded+=len(chunk)

          print(f"[done] uploaded={uploaded} rejected_parse={len(rejects)} api_errors={api_errs}")
          # never exit non-zero (best-effort)
          PY

      - name: Upload parse rejects (if any)
        uses: actions/upload-artifact@v4
        with:
          name: xdr-rejects
          path: rejects.json
          if-no-files-found: ignore
